================================================================================
VOID WARRANTY - SCRIPTS DOCUMENTATION v0.6
Architecture Complete et Code Source
Date: 2026-02-08
================================================================================

================================================================================
TABLE DES MATIERES
================================================================================

SETTINGS
  1. GameControls.cs

CORE
  2. IInteractable.cs
  3. ItemData.cs
  4. LocalizationManager.cs
  5. LocalizationTable.cs

INTERACTION
  6. ColorCube.cs
  7. GrabbableObject.cs
  8. PatientObject.cs
  9. RepairSocket.cs
  10. Scanner.cs
  11. SupplyCrate.cs
  12. TruckZone.cs

PLAYER
  13. PlayerCameraSetup.cs
  14. PlayerGrab.cs
  15. PlayerInputReader.cs
  16. PlayerInteraction.cs
  17. PlayerMovement.cs

UI
  18. InteractionHUD.cs

================================================================================
HIERARCHIE DU PROJET Assets/_Game
================================================================================

_Game/
├── Art/
│   ├── Materials/
│   │   ├── Mat_Blue.mat
│   │   ├── Mat_Burn.mat
│   │   ├── Mat_Grey.mat
│   │   └── Mat_Red.mat
│   ├── Models/
│   └── square.png
│
├── Audio/
│   └── Blip.wav
│
├── Data/
│   ├── Items/
│   │   ├── Data_Crate.asset
│   │   ├── Data_Motor_Broken.asset
│   │   ├── Data_Motor_New.asset
│   │   ├── Data_Scanner.asset
│   │   ├── Data_SupplyCrate.asset
│   │   └── Data_Toolbox.asset
│   └── Languages/
│       ├── English.csv
│       ├── French.csv
│       ├── Lang_EN.asset
│       └── Lang_FR.asset
│
├── Prefabs/
│   ├── Characters/
│   │   └── Player.prefab
│   ├── Patients/
│   │   ├── Patient.prefab
│   │   └── Patient_Fridge.prefab
│   └── Props/
│       ├── Cube.prefab
│       ├── Prop_Motor_Broken.prefab
│       ├── Prop_Motor_New.prefab
│       ├── Scanner.prefab
│       └── Toolbox_basic.prefab
│
├── Scenes/
│   └── Main_Proto.unity
│
├── Scripts/
│   ├── Core/
│   │   ├── IInteractable.cs
│   │   ├── ItemData.cs
│   │   ├── LocalizationManager.cs
│   │   └── LocalizationTable.cs
│   ├── Interaction/
│   │   ├── ColorCube.cs
│   │   ├── GrabbableObject.cs
│   │   ├── PatientObject.cs
│   │   ├── RepairSocket.cs
│   │   ├── Scanner.cs
│   │   ├── SupplyCrate.cs
│   │   └── TruckZone.cs
│   ├── Network/
│   ├── Player/
│   │   ├── PlayerCameraSetup.cs
│   │   ├── PlayerGrab.cs
│   │   ├── PlayerInputReader.cs
│   │   ├── PlayerInteraction.cs
│   │   └── PlayerMovement.cs
│   └── UI/
│       └── InteractionHUD.cs
│
└── Settings/
    ├── GameControls.cs
    └── GameControls.inputactions

================================================================================
CODE SOURCE DES SCRIPTS
================================================================================

--------------------------------------------------------------------------------
FICHIER: GameControls.cs
PATH: Assets/_Game/Settings/GameControls.cs
--------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was auto-generated by com.unity.inputsystem:InputActionCodeGenerator
//     version 1.18.0
//     from Assets/_Game/Settings/GameControls.inputactions
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.Utilities;

/// <summary>
/// Provides programmatic access to <see cref="InputActionAsset" />, <see cref="InputActionMap" />, <see cref="InputAction" /> and <see cref="InputControlScheme" /> instances defined in asset "Assets/_Game/Settings/GameControls.inputactions".
/// </summary>
/// <remarks>
/// This class is source generated and any manual edits will be discarded if the associated asset is reimported or modified.
/// </remarks>
/// <example>
/// <code>
/// using namespace UnityEngine;
/// using UnityEngine.InputSystem;
///
/// // Example of using an InputActionMap named "Player" from a UnityEngine.MonoBehaviour implementing callback interface.
/// public class Example : MonoBehaviour, MyActions.IPlayerActions
/// {
///     private MyActions_Actions m_Actions;                  // Source code representation of asset.
///     private MyActions_Actions.PlayerActions m_Player;     // Source code representation of action map.
///
///     void Awake()
///     {
///         m_Actions = new MyActions_Actions();              // Create asset object.
///         m_Player = m_Actions.Player;                      // Extract action map object.
///         m_Player.AddCallbacks(this);                      // Register callback interface IPlayerActions.
///     }
///
///     void OnDestroy()
///     {
///         m_Actions.Dispose();                              // Destroy asset object.
///     }
///
///     void OnEnable()
///     {
///         m_Player.Enable();                                // Enable all actions within map.
///     }
///
///     void OnDisable()
///     {
///         m_Player.Disable();                               // Disable all actions within map.
///     }
///
///     #region Interface implementation of MyActions.IPlayerActions
///
///     // Invoked when "Move" action is either started, performed or canceled.
///     public void OnMove(InputAction.CallbackContext context)
///     {
///         Debug.Log($"OnMove: {context.ReadValue<Vector2>()}");
///     }
///
///     // Invoked when "Attack" action is either started, performed or canceled.
///     public void OnAttack(InputAction.CallbackContext context)
///     {
///         Debug.Log($"OnAttack: {context.ReadValue<float>()}");
///     }
///
///     #endregion
/// }
/// </code>
/// </example>
public partial class @GameControls: IInputActionCollection2, IDisposable
{
    /// <summary>
    /// Provides access to the underlying asset instance.
    /// </summary>
    public InputActionAsset asset { get; }

    /// <summary>
    /// Constructs a new instance.
    /// </summary>
    public @GameControls()
    {
        asset = InputActionAsset.FromJson(@"{
    ""version"": 1,
    ""name"": ""GameControls"",
    ""maps"": [
        {
            ""name"": ""Player"",
            ""id"": ""df70fa95-8a34-4494-b137-73ab6b9c7d37"",
            ""actions"": [
                {
                    ""name"": ""Move"",
                    ""type"": ""Value"",
                    ""id"": ""351f2ccd-1f9f-44bf-9bec-d62ac5c5f408"",
                    ""expectedControlType"": ""Vector2"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": true
                },
                {
                    ""name"": ""Look"",
                    ""type"": ""Value"",
                    ""id"": ""6b444451-8a00-4d00-a97e-f47457f736a8"",
                    ""expectedControlType"": ""Vector2"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": true
                },
                {
                    ""name"": ""Grab"",
                    ""type"": ""Button"",
                    ""id"": ""6c2ab1b8-8984-453a-af3d-a3c78ae1679a"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Interact"",
                    ""type"": ""Button"",
                    ""id"": ""852140f2-7766-474d-8707-702459ba45f3"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": ""Hold"",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Crouch"",
                    ""type"": ""Button"",
                    ""id"": ""27c5f898-bc57-4ee1-8800-db469aca5fe3"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Jump"",
                    ""type"": ""Button"",
                    ""id"": ""f1ba0d36-48eb-4cd5-b651-1c94a6531f70"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Previous"",
                    ""type"": ""Button"",
                    ""id"": ""2776c80d-3c14-4091-8c56-d04ced07a2b0"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Next"",
                    ""type"": ""Button"",
                    ""id"": ""b7230bb6-fc9b-4f52-8b25-f5e19cb2c2ba"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Sprint"",
                    ""type"": ""Button"",
                    ""id"": ""641cd816-40e6-41b4-8c3d-04687c349290"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": """",
                    ""id"": ""978bfe49-cc26-4a3d-ab7b-7d7a29327403"",
                    ""path"": ""<Gamepad>/leftStick"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Gamepad"",
                    ""action"": ""Move"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""WASD"",
                    ""id"": ""00ca640b-d935-4593-8157-c05846ea39b3"",
                    ""path"": ""Dpad"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Move"",
                    ""isComposite"": true,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""up"",
                    ""id"": ""e2062cb9-1b15-46a2-838c-2f8d72a0bdd9"",
                    ""path"": ""<Keyboard>/w"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Keyboard&Mouse"",
                    ""action"": ""Move"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""up"",
                    ""id"": ""8180e8bd-4097-4f4e-ab88-4523101a6ce9"",
                    ""path"": ""<Keyboard>/upArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Keyboard&Mouse"",
                    ""action"": ""Move"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""down"",
                    ""id"": ""320bffee-a40b-4347-ac70-c210eb8bc73a"",
                    ""path"": ""<Keyboard>/s"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Keyboard&Mouse"",
                    ""action"": ""Move"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""down"",
                    ""id"": ""1c5327b5-f71c-4f60-99c7-4e737386f1d1"",
                    ""path"": ""<Keyboard>/downArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Keyboard&Mouse"",
                    ""action"": ""Move"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""left"",
                    ""id"": ""d2581a9b-1d11-4566-b27d-b92aff5fabbc"",
                    ""path"": ""<Keyboard>/a"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Keyboard&Mouse"",
                    ""action"": ""Move"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""left"",
                    ""id"": ""2e46982e-44cc-431b-9f0b-c11910bf467a"",
                    ""path"": ""<Keyboard>/leftArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Keyboard&Mouse"",
                    ""action"": ""Move"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""right"",
                    ""id"": ""fcfe95b8-67b9-4526-84b5-5d0bc98d6400"",
                    ""path"": ""<Keyboard>/d"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Keyboard&Mouse"",
                    ""action"": ""Move"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""right"",
                    ""id"": ""77bff152-3580-4b21-b6de-dcd0c7e41164"",
                    ""path"": ""<Keyboard>/rightArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Keyboard&Mouse"",
                    ""action"": ""Move"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": """",
                    ""id"": ""1635d3fe-58b6-4ba9-a4e2-f4b964f6b5c8"",
                    ""path"": ""<XRController>/{Primary2DAxis}"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""XR"",
                    ""action"": ""Move"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""3ea4d645-4504-4529-b061-ab81934c3752"",
                    ""path"": ""<Joystick>/stick"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Joystick"",
                    ""action"": ""Move"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""c1f7a91b-d0fd-4a62-997e-7fb9b69bf235"",
                    ""path"": ""<Gamepad>/rightStick"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Gamepad"",
                    ""action"": ""Look"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""8c8e490b-c610-4785-884f-f04217b23ca4"",
                    ""path"": ""<Pointer>/delta"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Keyboard&Mouse;Touch"",
                    ""action"": ""Look"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""3e5f5442-8668-4b27-a940-df99bad7e831"",
                    ""path"": ""<Joystick>/{Hatswitch}"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Joystick"",
                    ""action"": ""Look"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""143bb1cd-cc10-4eca-a2f0-a3664166fe91"",
                    ""path"": ""<Gamepad>/buttonWest"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Gamepad"",
                    ""action"": ""Grab"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""05f6913d-c316-48b2-a6bb-e225f14c7960"",
                    ""path"": ""<Mouse>/leftButton"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Keyboard&Mouse"",
                    ""action"": ""Grab"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""886e731e-7071-4ae4-95c0-e61739dad6fd"",
                    ""path"": ""<Touchscreen>/primaryTouch/tap"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Touch"",
                    ""action"": ""Grab"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""ee3d0cd2-254e-47a7-a8cb-bc94d9658c54"",
                    ""path"": ""<Joystick>/trigger"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Joystick"",
                    ""action"": ""Grab"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""8255d333-5683-4943-a58a-ccb207ff1dce"",
                    ""path"": ""<XRController>/{PrimaryAction}"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""XR"",
                    ""action"": ""Grab"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""b3c1c7f0-bd20-4ee7-a0f1-899b24bca6d7"",
                    ""path"": ""<Keyboard>/enter"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard&Mouse"",
                    ""action"": ""Grab"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""cbac6039-9c09-46a1-b5f2-4e5124ccb5ed"",
                    ""path"": ""<Keyboard>/2"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard&Mouse"",
                    ""action"": ""Next"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""e15ca19d-e649-4852-97d5-7fe8ccc44e94"",
                    ""path"": ""<Gamepad>/dpad/right"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Gamepad"",
                    ""action"": ""Next"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""f2e9ba44-c423-42a7-ad56-f20975884794"",
                    ""path"": ""<Keyboard>/leftShift"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard&Mouse"",
                    ""action"": ""Sprint"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""8cbb2f4b-a784-49cc-8d5e-c010b8c7f4e6"",
                    ""path"": ""<Gamepad>/leftStickPress"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Gamepad"",
                    ""action"": ""Sprint"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""d8bf24bf-3f2f-4160-a97c-38ec1eb520ba"",
                    ""path"": ""<XRController>/trigger"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""XR"",
                    ""action"": ""Sprint"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""eb40bb66-4559-4dfa-9a2f-820438abb426"",
                    ""path"": ""<Keyboard>/space"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard&Mouse"",
                    ""action"": ""Jump"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""daba33a1-ad0c-4742-a909-43ad1cdfbeb6"",
                    ""path"": ""<Gamepad>/buttonSouth"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Gamepad"",
                    ""action"": ""Jump"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""603f3daf-40bd-4854-8724-93e8017f59e3"",
                    ""path"": ""<XRController>/secondaryButton"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""XR"",
                    ""action"": ""Jump"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""1534dc16-a6aa-499d-9c3a-22b47347b52a"",
                    ""path"": ""<Keyboard>/1"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard&Mouse"",
                    ""action"": ""Previous"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""25060bbd-a3a6-476e-8fba-45ae484aad05"",
                    ""path"": ""<Gamepad>/dpad/left"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Gamepad"",
                    ""action"": ""Previous"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""1c04ea5f-b012-41d1-a6f7-02e963b52893"",
                    ""path"": ""<Keyboard>/e"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard&Mouse"",
                    ""action"": ""Interact"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""b3f66d0b-7751-423f-908b-a11c5bd95930"",
                    ""path"": ""<Gamepad>/buttonNorth"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Gamepad"",
                    ""action"": ""Interact"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""4f4649ac-64a8-4a73-af11-b3faef356a4d"",
                    ""path"": ""<Gamepad>/buttonEast"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Gamepad"",
                    ""action"": ""Crouch"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""36e52cba-0905-478e-a818-f4bfcb9f3b9a"",
                    ""path"": ""<Keyboard>/c"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard&Mouse"",
                    ""action"": ""Crouch"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                }
            ]
        },
        {
            ""name"": ""UI"",
            ""id"": ""272f6d14-89ba-496f-b7ff-215263d3219f"",
            ""actions"": [
                {
                    ""name"": ""Navigate"",
                    ""type"": ""PassThrough"",
                    ""id"": ""c95b2375-e6d9-4b88-9c4c-c5e76515df4b"",
                    ""expectedControlType"": ""Vector2"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Submit"",
                    ""type"": ""Button"",
                    ""id"": ""7607c7b6-cd76-4816-beef-bd0341cfe950"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Cancel"",
                    ""type"": ""Button"",
                    ""id"": ""15cef263-9014-4fd5-94d9-4e4a6234a6ef"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Point"",
                    ""type"": ""PassThrough"",
                    ""id"": ""32b35790-4ed0-4e9a-aa41-69ac6d629449"",
                    ""expectedControlType"": ""Vector2"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": true
                },
                {
                    ""name"": ""Click"",
                    ""type"": ""PassThrough"",
                    ""id"": ""3c7022bf-7922-4f7c-a998-c437916075ad"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": true
                },
                {
                    ""name"": ""RightClick"",
                    ""type"": ""PassThrough"",
                    ""id"": ""44b200b1-1557-4083-816c-b22cbdf77ddf"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""MiddleClick"",
                    ""type"": ""PassThrough"",
                    ""id"": ""dad70c86-b58c-4b17-88ad-f5e53adf419e"",
                    ""expectedControlType"": ""Button"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""ScrollWheel"",
                    ""type"": ""PassThrough"",
                    ""id"": ""0489e84a-4833-4c40-bfae-cea84b696689"",
                    ""expectedControlType"": ""Vector2"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""TrackedDevicePosition"",
                    ""type"": ""PassThrough"",
                    ""id"": ""24908448-c609-4bc3-a128-ea258674378a"",
                    ""expectedControlType"": ""Vector3"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""TrackedDeviceOrientation"",
                    ""type"": ""PassThrough"",
                    ""id"": ""9caa3d8a-6b2f-4e8e-8bad-6ede561bd9be"",
                    ""expectedControlType"": ""Quaternion"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": ""Gamepad"",
                    ""id"": ""809f371f-c5e2-4e7a-83a1-d867598f40dd"",
                    ""path"": ""2DVector"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": true,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""up"",
                    ""id"": ""14a5d6e8-4aaf-4119-a9ef-34b8c2c548bf"",
                    ""path"": ""<Gamepad>/leftStick/up"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Gamepad"",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""up"",
                    ""id"": ""9144cbe6-05e1-4687-a6d7-24f99d23dd81"",
                    ""path"": ""<Gamepad>/rightStick/up"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Gamepad"",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""down"",
                    ""id"": ""2db08d65-c5fb-421b-983f-c71163608d67"",
                    ""path"": ""<Gamepad>/leftStick/down"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Gamepad"",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""down"",
                    ""id"": ""58748904-2ea9-4a80-8579-b500e6a76df8"",
                    ""path"": ""<Gamepad>/rightStick/down"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Gamepad"",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""left"",
                    ""id"": ""8ba04515-75aa-45de-966d-393d9bbd1c14"",
                    ""path"": ""<Gamepad>/leftStick/left"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Gamepad"",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""left"",
                    ""id"": ""712e721c-bdfb-4b23-a86c-a0d9fcfea921"",
                    ""path"": ""<Gamepad>/rightStick/left"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Gamepad"",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""right"",
                    ""id"": ""fcd248ae-a788-4676-a12e-f4d81205600b"",
                    ""path"": ""<Gamepad>/leftStick/right"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Gamepad"",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""right"",
                    ""id"": ""1f04d9bc-c50b-41a1-bfcc-afb75475ec20"",
                    ""path"": ""<Gamepad>/rightStick/right"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Gamepad"",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": """",
                    ""id"": ""fb8277d4-c5cd-4663-9dc7-ee3f0b506d90"",
                    ""path"": ""<Gamepad>/dpad"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Gamepad"",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""Joystick"",
                    ""id"": ""e25d9774-381c-4a61-b47c-7b6b299ad9f9"",
                    ""path"": ""2DVector"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": true,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""up"",
                    ""id"": ""3db53b26-6601-41be-9887-63ac74e79d19"",
                    ""path"": ""<Joystick>/stick/up"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Joystick"",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""down"",
                    ""id"": ""0cb3e13e-3d90-4178-8ae6-d9c5501d653f"",
                    ""path"": ""<Joystick>/stick/down"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Joystick"",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""left"",
                    ""id"": ""0392d399-f6dd-4c82-8062-c1e9c0d34835"",
                    ""path"": ""<Joystick>/stick/left"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Joystick"",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""right"",
                    ""id"": ""942a66d9-d42f-43d6-8d70-ecb4ba5363bc"",
                    ""path"": ""<Joystick>/stick/right"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Joystick"",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""Keyboard"",
                    ""id"": ""ff527021-f211-4c02-933e-5976594c46ed"",
                    ""path"": ""2DVector"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Navigate"",
                    ""isComposite"": true,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": ""up"",
                    ""id"": ""563fbfdd-0f09-408d-aa75-8642c4f08ef0"",
                    ""path"": ""<Keyboard>/w"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard&Mouse"",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""up"",
                    ""id"": ""eb480147-c587-4a33-85ed-eb0ab9942c43"",
                    ""path"": ""<Keyboard>/upArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard&Mouse"",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""down"",
                    ""id"": ""2bf42165-60bc-42ca-8072-8c13ab40239b"",
                    ""path"": ""<Keyboard>/s"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard&Mouse"",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""down"",
                    ""id"": ""85d264ad-e0a0-4565-b7ff-1a37edde51ac"",
                    ""path"": ""<Keyboard>/downArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard&Mouse"",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""left"",
                    ""id"": ""74214943-c580-44e4-98eb-ad7eebe17902"",
                    ""path"": ""<Keyboard>/a"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard&Mouse"",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""left"",
                    ""id"": ""cea9b045-a000-445b-95b8-0c171af70a3b"",
                    ""path"": ""<Keyboard>/leftArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard&Mouse"",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""right"",
                    ""id"": ""8607c725-d935-4808-84b1-8354e29bab63"",
                    ""path"": ""<Keyboard>/d"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard&Mouse"",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": ""right"",
                    ""id"": ""4cda81dc-9edd-4e03-9d7c-a71a14345d0b"",
                    ""path"": ""<Keyboard>/rightArrow"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard&Mouse"",
                    ""action"": ""Navigate"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": true
                },
                {
                    ""name"": """",
                    ""id"": ""9e92bb26-7e3b-4ec4-b06b-3c8f8e498ddc"",
                    ""path"": ""*/{Submit}"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard&Mouse;Gamepad;Touch;Joystick;XR"",
                    ""action"": ""Submit"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""82627dcc-3b13-4ba9-841d-e4b746d6553e"",
                    ""path"": ""*/{Cancel}"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard&Mouse;Gamepad;Touch;Joystick;XR"",
                    ""action"": ""Cancel"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""c52c8e0b-8179-41d3-b8a1-d149033bbe86"",
                    ""path"": ""<Mouse>/position"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard&Mouse"",
                    ""action"": ""Point"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""e1394cbc-336e-44ce-9ea8-6007ed6193f7"",
                    ""path"": ""<Pen>/position"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard&Mouse"",
                    ""action"": ""Point"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""5693e57a-238a-46ed-b5ae-e64e6e574302"",
                    ""path"": ""<Touchscreen>/touch*/position"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Touch"",
                    ""action"": ""Point"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""4faf7dc9-b979-4210-aa8c-e808e1ef89f5"",
                    ""path"": ""<Mouse>/leftButton"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Keyboard&Mouse"",
                    ""action"": ""Click"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""8d66d5ba-88d7-48e6-b1cd-198bbfef7ace"",
                    ""path"": ""<Pen>/tip"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Keyboard&Mouse"",
                    ""action"": ""Click"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""47c2a644-3ebc-4dae-a106-589b7ca75b59"",
                    ""path"": ""<Touchscreen>/touch*/press"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Touch"",
                    ""action"": ""Click"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""bb9e6b34-44bf-4381-ac63-5aa15d19f677"",
                    ""path"": ""<XRController>/trigger"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""XR"",
                    ""action"": ""Click"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""38c99815-14ea-4617-8627-164d27641299"",
                    ""path"": ""<Mouse>/scroll"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": "";Keyboard&Mouse"",
                    ""action"": ""ScrollWheel"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""4c191405-5738-4d4b-a523-c6a301dbf754"",
                    ""path"": ""<Mouse>/rightButton"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard&Mouse"",
                    ""action"": ""RightClick"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""24066f69-da47-44f3-a07e-0015fb02eb2e"",
                    ""path"": ""<Mouse>/middleButton"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""Keyboard&Mouse"",
                    ""action"": ""MiddleClick"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""7236c0d9-6ca3-47cf-a6ee-a97f5b59ea77"",
                    ""path"": ""<XRController>/devicePosition"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""XR"",
                    ""action"": ""TrackedDevicePosition"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""23e01e3a-f935-4948-8d8b-9bcac77714fb"",
                    ""path"": ""<XRController>/deviceRotation"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": ""XR"",
                    ""action"": ""TrackedDeviceOrientation"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                }
            ]
        }
    ],
    ""controlSchemes"": [
        {
            ""name"": ""Keyboard&Mouse"",
            ""bindingGroup"": ""Keyboard&Mouse"",
            ""devices"": [
                {
                    ""devicePath"": ""<Keyboard>"",
                    ""isOptional"": false,
                    ""isOR"": false
                },
                {
                    ""devicePath"": ""<Mouse>"",
                    ""isOptional"": false,
                    ""isOR"": false
                }
            ]
        },
        {
            ""name"": ""Gamepad"",
            ""bindingGroup"": ""Gamepad"",
            ""devices"": [
                {
                    ""devicePath"": ""<Gamepad>"",
                    ""isOptional"": false,
                    ""isOR"": false
                }
            ]
        },
        {
            ""name"": ""Touch"",
            ""bindingGroup"": ""Touch"",
            ""devices"": [
                {
                    ""devicePath"": ""<Touchscreen>"",
                    ""isOptional"": false,
                    ""isOR"": false
                }
            ]
        },
        {
            ""name"": ""Joystick"",
            ""bindingGroup"": ""Joystick"",
            ""devices"": [
                {
                    ""devicePath"": ""<Joystick>"",
                    ""isOptional"": false,
                    ""isOR"": false
                }
            ]
        },
        {
            ""name"": ""XR"",
            ""bindingGroup"": ""XR"",
            ""devices"": [
                {
                    ""devicePath"": ""<XRController>"",
                    ""isOptional"": false,
                    ""isOR"": false
                }
            ]
        }
    ]
}");
        // Player
        m_Player = asset.FindActionMap("Player", throwIfNotFound: true);
        m_Player_Move = m_Player.FindAction("Move", throwIfNotFound: true);
        m_Player_Look = m_Player.FindAction("Look", throwIfNotFound: true);
        m_Player_Grab = m_Player.FindAction("Grab", throwIfNotFound: true);
        m_Player_Interact = m_Player.FindAction("Interact", throwIfNotFound: true);
        m_Player_Crouch = m_Player.FindAction("Crouch", throwIfNotFound: true);
        m_Player_Jump = m_Player.FindAction("Jump", throwIfNotFound: true);
        m_Player_Previous = m_Player.FindAction("Previous", throwIfNotFound: true);
        m_Player_Next = m_Player.FindAction("Next", throwIfNotFound: true);
        m_Player_Sprint = m_Player.FindAction("Sprint", throwIfNotFound: true);
        // UI
        m_UI = asset.FindActionMap("UI", throwIfNotFound: true);
        m_UI_Navigate = m_UI.FindAction("Navigate", throwIfNotFound: true);
        m_UI_Submit = m_UI.FindAction("Submit", throwIfNotFound: true);
        m_UI_Cancel = m_UI.FindAction("Cancel", throwIfNotFound: true);
        m_UI_Point = m_UI.FindAction("Point", throwIfNotFound: true);
        m_UI_Click = m_UI.FindAction("Click", throwIfNotFound: true);
        m_UI_RightClick = m_UI.FindAction("RightClick", throwIfNotFound: true);
        m_UI_MiddleClick = m_UI.FindAction("MiddleClick", throwIfNotFound: true);
        m_UI_ScrollWheel = m_UI.FindAction("ScrollWheel", throwIfNotFound: true);
        m_UI_TrackedDevicePosition = m_UI.FindAction("TrackedDevicePosition", throwIfNotFound: true);
        m_UI_TrackedDeviceOrientation = m_UI.FindAction("TrackedDeviceOrientation", throwIfNotFound: true);
    }

    ~@GameControls()
    {
        UnityEngine.Debug.Assert(!m_Player.enabled, "This will cause a leak and performance issues, GameControls.Player.Disable() has not been called.");
        UnityEngine.Debug.Assert(!m_UI.enabled, "This will cause a leak and performance issues, GameControls.UI.Disable() has not been called.");
    }

    public void Dispose()
    {
        UnityEngine.Object.Destroy(asset);
    }

    public InputBinding? bindingMask
    {
        get => asset.bindingMask;
        set => asset.bindingMask = value;
    }

    public ReadOnlyArray<InputDevice>? devices
    {
        get => asset.devices;
        set => asset.devices = value;
    }

    public ReadOnlyArray<InputControlScheme> controlSchemes => asset.controlSchemes;

    public bool Contains(InputAction action)
    {
        return asset.Contains(action);
    }

    public IEnumerator<InputAction> GetEnumerator()
    {
        return asset.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }

    public void Enable()
    {
        asset.Enable();
    }

    public void Disable()
    {
        asset.Disable();
    }

    public IEnumerable<InputBinding> bindings => asset.bindings;

    public InputAction FindAction(string actionNameOrId, bool throwIfNotFound = false)
    {
        return asset.FindAction(actionNameOrId, throwIfNotFound);
    }

    public int FindBinding(InputBinding bindingMask, out InputAction action)
    {
        return asset.FindBinding(bindingMask, out action);
    }

    // Player
    private readonly InputActionMap m_Player;
    private List<IPlayerActions> m_PlayerActionsCallbackInterfaces = new List<IPlayerActions>();
    private readonly InputAction m_Player_Move;
    private readonly InputAction m_Player_Look;
    private readonly InputAction m_Player_Grab;
    private readonly InputAction m_Player_Interact;
    private readonly InputAction m_Player_Crouch;
    private readonly InputAction m_Player_Jump;
    private readonly InputAction m_Player_Previous;
    private readonly InputAction m_Player_Next;
    private readonly InputAction m_Player_Sprint;

    public struct PlayerActions
    {
        private @GameControls m_Wrapper;
        public PlayerActions(@GameControls wrapper) { m_Wrapper = wrapper; }
        public InputAction @Move => m_Wrapper.m_Player_Move;
        public InputAction @Look => m_Wrapper.m_Player_Look;
        public InputAction @Grab => m_Wrapper.m_Player_Grab;
        public InputAction @Interact => m_Wrapper.m_Player_Interact;
        public InputAction @Crouch => m_Wrapper.m_Player_Crouch;
        public InputAction @Jump => m_Wrapper.m_Player_Jump;
        public InputAction @Previous => m_Wrapper.m_Player_Previous;
        public InputAction @Next => m_Wrapper.m_Player_Next;
        public InputAction @Sprint => m_Wrapper.m_Player_Sprint;
        public InputActionMap Get() { return m_Wrapper.m_Player; }
        public void Enable() { Get().Enable(); }
        public void Disable() { Get().Disable(); }
        public bool enabled => Get().enabled;
        public static implicit operator InputActionMap(PlayerActions set) { return set.Get(); }

        public void AddCallbacks(IPlayerActions instance)
        {
            if (instance == null || m_Wrapper.m_PlayerActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_PlayerActionsCallbackInterfaces.Add(instance);
            @Move.started += instance.OnMove;
            @Move.performed += instance.OnMove;
            @Move.canceled += instance.OnMove;
            @Look.started += instance.OnLook;
            @Look.performed += instance.OnLook;
            @Look.canceled += instance.OnLook;
            @Grab.started += instance.OnGrab;
            @Grab.performed += instance.OnGrab;
            @Grab.canceled += instance.OnGrab;
            @Interact.started += instance.OnInteract;
            @Interact.performed += instance.OnInteract;
            @Interact.canceled += instance.OnInteract;
            @Crouch.started += instance.OnCrouch;
            @Crouch.performed += instance.OnCrouch;
            @Crouch.canceled += instance.OnCrouch;
            @Jump.started += instance.OnJump;
            @Jump.performed += instance.OnJump;
            @Jump.canceled += instance.OnJump;
            @Previous.started += instance.OnPrevious;
            @Previous.performed += instance.OnPrevious;
            @Previous.canceled += instance.OnPrevious;
            @Next.started += instance.OnNext;
            @Next.performed += instance.OnNext;
            @Next.canceled += instance.OnNext;
            @Sprint.started += instance.OnSprint;
            @Sprint.performed += instance.OnSprint;
            @Sprint.canceled += instance.OnSprint;
        }

        private void UnregisterCallbacks(IPlayerActions instance)
        {
            @Move.started -= instance.OnMove;
            @Move.performed -= instance.OnMove;
            @Move.canceled -= instance.OnMove;
            @Look.started -= instance.OnLook;
            @Look.performed -= instance.OnLook;
            @Look.canceled -= instance.OnLook;
            @Grab.started -= instance.OnGrab;
            @Grab.performed -= instance.OnGrab;
            @Grab.canceled -= instance.OnGrab;
            @Interact.started -= instance.OnInteract;
            @Interact.performed -= instance.OnInteract;
            @Interact.canceled -= instance.OnInteract;
            @Crouch.started -= instance.OnCrouch;
            @Crouch.performed -= instance.OnCrouch;
            @Crouch.canceled -= instance.OnCrouch;
            @Jump.started -= instance.OnJump;
            @Jump.performed -= instance.OnJump;
            @Jump.canceled -= instance.OnJump;
            @Previous.started -= instance.OnPrevious;
            @Previous.performed -= instance.OnPrevious;
            @Previous.canceled -= instance.OnPrevious;
            @Next.started -= instance.OnNext;
            @Next.performed -= instance.OnNext;
            @Next.canceled -= instance.OnNext;
            @Sprint.started -= instance.OnSprint;
            @Sprint.performed -= instance.OnSprint;
            @Sprint.canceled -= instance.OnSprint;
        }

        public void RemoveCallbacks(IPlayerActions instance)
        {
            if (m_Wrapper.m_PlayerActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        public void SetCallbacks(IPlayerActions instance)
        {
            foreach (var item in m_Wrapper.m_PlayerActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_PlayerActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }

    public PlayerActions @Player => new PlayerActions(this);

    // UI
    private readonly InputActionMap m_UI;
    private List<IUIActions> m_UIActionsCallbackInterfaces = new List<IUIActions>();
    private readonly InputAction m_UI_Navigate;
    private readonly InputAction m_UI_Submit;
    private readonly InputAction m_UI_Cancel;
    private readonly InputAction m_UI_Point;
    private readonly InputAction m_UI_Click;
    private readonly InputAction m_UI_RightClick;
    private readonly InputAction m_UI_MiddleClick;
    private readonly InputAction m_UI_ScrollWheel;
    private readonly InputAction m_UI_TrackedDevicePosition;
    private readonly InputAction m_UI_TrackedDeviceOrientation;

    public struct UIActions
    {
        private @GameControls m_Wrapper;
        public UIActions(@GameControls wrapper) { m_Wrapper = wrapper; }
        public InputAction @Navigate => m_Wrapper.m_UI_Navigate;
        public InputAction @Submit => m_Wrapper.m_UI_Submit;
        public InputAction @Cancel => m_Wrapper.m_UI_Cancel;
        public InputAction @Point => m_Wrapper.m_UI_Point;
        public InputAction @Click => m_Wrapper.m_UI_Click;
        public InputAction @RightClick => m_Wrapper.m_UI_RightClick;
        public InputAction @MiddleClick => m_Wrapper.m_UI_MiddleClick;
        public InputAction @ScrollWheel => m_Wrapper.m_UI_ScrollWheel;
        public InputAction @TrackedDevicePosition => m_Wrapper.m_UI_TrackedDevicePosition;
        public InputAction @TrackedDeviceOrientation => m_Wrapper.m_UI_TrackedDeviceOrientation;
        public InputActionMap Get() { return m_Wrapper.m_UI; }
        public void Enable() { Get().Enable(); }
        public void Disable() { Get().Disable(); }
        public bool enabled => Get().enabled;
        public static implicit operator InputActionMap(UIActions set) { return set.Get(); }

        public void AddCallbacks(IUIActions instance)
        {
            if (instance == null || m_Wrapper.m_UIActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_UIActionsCallbackInterfaces.Add(instance);
            @Navigate.started += instance.OnNavigate;
            @Navigate.performed += instance.OnNavigate;
            @Navigate.canceled += instance.OnNavigate;
            @Submit.started += instance.OnSubmit;
            @Submit.performed += instance.OnSubmit;
            @Submit.canceled += instance.OnSubmit;
            @Cancel.started += instance.OnCancel;
            @Cancel.performed += instance.OnCancel;
            @Cancel.canceled += instance.OnCancel;
            @Point.started += instance.OnPoint;
            @Point.performed += instance.OnPoint;
            @Point.canceled += instance.OnPoint;
            @Click.started += instance.OnClick;
            @Click.performed += instance.OnClick;
            @Click.canceled += instance.OnClick;
            @RightClick.started += instance.OnRightClick;
            @RightClick.performed += instance.OnRightClick;
            @RightClick.canceled += instance.OnRightClick;
            @MiddleClick.started += instance.OnMiddleClick;
            @MiddleClick.performed += instance.OnMiddleClick;
            @MiddleClick.canceled += instance.OnMiddleClick;
            @ScrollWheel.started += instance.OnScrollWheel;
            @ScrollWheel.performed += instance.OnScrollWheel;
            @ScrollWheel.canceled += instance.OnScrollWheel;
            @TrackedDevicePosition.started += instance.OnTrackedDevicePosition;
            @TrackedDevicePosition.performed += instance.OnTrackedDevicePosition;
            @TrackedDevicePosition.canceled += instance.OnTrackedDevicePosition;
            @TrackedDeviceOrientation.started += instance.OnTrackedDeviceOrientation;
            @TrackedDeviceOrientation.performed += instance.OnTrackedDeviceOrientation;
            @TrackedDeviceOrientation.canceled += instance.OnTrackedDeviceOrientation;
        }

        private void UnregisterCallbacks(IUIActions instance)
        {
            @Navigate.started -= instance.OnNavigate;
            @Navigate.performed -= instance.OnNavigate;
            @Navigate.canceled -= instance.OnNavigate;
            @Submit.started -= instance.OnSubmit;
            @Submit.performed -= instance.OnSubmit;
            @Submit.canceled -= instance.OnSubmit;
            @Cancel.started -= instance.OnCancel;
            @Cancel.performed -= instance.OnCancel;
            @Cancel.canceled -= instance.OnCancel;
            @Point.started -= instance.OnPoint;
            @Point.performed -= instance.OnPoint;
            @Point.canceled -= instance.OnPoint;
            @Click.started -= instance.OnClick;
            @Click.performed -= instance.OnClick;
            @Click.canceled -= instance.OnClick;
            @RightClick.started -= instance.OnRightClick;
            @RightClick.performed -= instance.OnRightClick;
            @RightClick.canceled -= instance.OnRightClick;
            @MiddleClick.started -= instance.OnMiddleClick;
            @MiddleClick.performed -= instance.OnMiddleClick;
            @MiddleClick.canceled -= instance.OnMiddleClick;
            @ScrollWheel.started -= instance.OnScrollWheel;
            @ScrollWheel.performed -= instance.OnScrollWheel;
            @ScrollWheel.canceled -= instance.OnScrollWheel;
            @TrackedDevicePosition.started -= instance.OnTrackedDevicePosition;
            @TrackedDevicePosition.performed -= instance.OnTrackedDevicePosition;
            @TrackedDevicePosition.canceled -= instance.OnTrackedDevicePosition;
            @TrackedDeviceOrientation.started -= instance.OnTrackedDeviceOrientation;
            @TrackedDeviceOrientation.performed -= instance.OnTrackedDeviceOrientation;
            @TrackedDeviceOrientation.canceled -= instance.OnTrackedDeviceOrientation;
        }

        public void RemoveCallbacks(IUIActions instance)
        {
            if (m_Wrapper.m_UIActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        public void SetCallbacks(IUIActions instance)
        {
            foreach (var item in m_Wrapper.m_UIActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_UIActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }

    public UIActions @UI => new UIActions(this);
    private int m_KeyboardMouseSchemeIndex = -1;

    public InputControlScheme KeyboardMouseScheme
    {
        get
        {
            if (m_KeyboardMouseSchemeIndex == -1) m_KeyboardMouseSchemeIndex = asset.FindControlSchemeIndex("Keyboard&Mouse");
            return asset.controlSchemes[m_KeyboardMouseSchemeIndex];
        }
    }
    private int m_GamepadSchemeIndex = -1;

    public InputControlScheme GamepadScheme
    {
        get
        {
            if (m_GamepadSchemeIndex == -1) m_GamepadSchemeIndex = asset.FindControlSchemeIndex("Gamepad");
            return asset.controlSchemes[m_GamepadSchemeIndex];
        }
    }
    private int m_TouchSchemeIndex = -1;

    public InputControlScheme TouchScheme
    {
        get
        {
            if (m_TouchSchemeIndex == -1) m_TouchSchemeIndex = asset.FindControlSchemeIndex("Touch");
            return asset.controlSchemes[m_TouchSchemeIndex];
        }
    }
    private int m_JoystickSchemeIndex = -1;

    public InputControlScheme JoystickScheme
    {
        get
        {
            if (m_JoystickSchemeIndex == -1) m_JoystickSchemeIndex = asset.FindControlSchemeIndex("Joystick");
            return asset.controlSchemes[m_JoystickSchemeIndex];
        }
    }
    private int m_XRSchemeIndex = -1;

    public InputControlScheme XRScheme
    {
        get
        {
            if (m_XRSchemeIndex == -1) m_XRSchemeIndex = asset.FindControlSchemeIndex("XR");
            return asset.controlSchemes[m_XRSchemeIndex];
        }
    }

    public interface IPlayerActions
    {
        void OnMove(InputAction.CallbackContext context);
        void OnLook(InputAction.CallbackContext context);
        void OnGrab(InputAction.CallbackContext context);
        void OnInteract(InputAction.CallbackContext context);
        void OnCrouch(InputAction.CallbackContext context);
        void OnJump(InputAction.CallbackContext context);
        void OnPrevious(InputAction.CallbackContext context);
        void OnNext(InputAction.CallbackContext context);
        void OnSprint(InputAction.CallbackContext context);
    }

    public interface IUIActions
    {
        void OnNavigate(InputAction.CallbackContext context);
        void OnSubmit(InputAction.CallbackContext context);
        void OnCancel(InputAction.CallbackContext context);
        void OnPoint(InputAction.CallbackContext context);
        void OnClick(InputAction.CallbackContext context);
        void OnRightClick(InputAction.CallbackContext context);
        void OnMiddleClick(InputAction.CallbackContext context);
        void OnScrollWheel(InputAction.CallbackContext context);
        void OnTrackedDevicePosition(InputAction.CallbackContext context);
        void OnTrackedDeviceOrientation(InputAction.CallbackContext context);
    }
}

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FICHIER: IInteractable.cs
PATH: Assets/_Game/Scripts/Core/IInteractable.cs
--------------------------------------------------------------------------------
using UnityEngine;

namespace VoidWarranty.Core
{
    // Tout objet qui veut être cliqué DOIT posséder un script qui implémente ça.
    public interface IInteractable
    {
        // On passe l'info de QUI interagit (pour savoir qui a appuyé sur le bouton)
        void Interact(GameObject interactor);

        // Optionnel : Pour afficher un texte "Appuyez sur E pour ouvrir"
        string GetInteractionPrompt();
    }
}

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FICHIER: ItemData.cs
PATH: Assets/_Game/Scripts/Core/ItemData.cs
--------------------------------------------------------------------------------
using UnityEngine;

namespace VoidWarranty.Core
{
    // Ajout de Toolbox et Scanner
    public enum ItemType
    {
        Generic,
        Motor,
        Fuse,
        Coolant,
        Toolbox,
        ToolboxAdvanced,
        Scanner
    }

    [CreateAssetMenu(fileName = "New Item", menuName = "VoidWarranty/Item Data")]
    public class ItemData : ScriptableObject
    {
        [Header("Clés de Traduction")]
        public string NameKey = "ITEM_NAME";
        public string DescriptionKey = "ITEM_DESC";

        [Header("Gameplay")]
        public ItemType Type = ItemType.Generic;
        public bool IsDefective = false;
        public int ScrapValue = 10;

        [Header("Physique")]
        public float Mass = 5f;
        public float LinearDamping = 0f;
        public float AngularDamping = 10f;

        // --- NOUVEAU : Positionnement en main ---
        [Header("Position en Main (Offset)")]
        // Par défaut (0,0,0) = Sur le HoldPoint exact
        public Vector3 HeldPositionOffset = Vector3.zero;

        // Rotation ajoutée (ex: incliner le scanner vers le visage)
        public Vector3 HeldRotationOffset = Vector3.zero;
    }
}

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FICHIER: LocalizationManager.cs
PATH: Assets/_Game/Scripts/Core/LocalizationManager.cs
--------------------------------------------------------------------------------
using UnityEngine;

namespace VoidWarranty.Core
{
    public class LocalizationManager : MonoBehaviour
    {
        public static LocalizationManager Instance;

        [Header("Langue Active")]
        [SerializeField] private LocalizationTable _currentLanguage;

        private void Awake()
        {
            if (Instance == null) Instance = this;
            else Destroy(gameObject);

            if (_currentLanguage != null)
            {
                _currentLanguage.Initialize();
                Debug.Log($"Langue chargée : {_currentLanguage.LanguageName}");
            }
        }

        public static string Get(string key)
        {
            if (Instance == null) return $"[NO_MANAGER:{key}]";
            if (Instance._currentLanguage == null) return $"[NO_LANG:{key}]";

            return Instance._currentLanguage.Get(key);
        }
    }
}

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FICHIER: LocalizationTable.cs
PATH: Assets/_Game/Scripts/Core/LocalizationTable.cs
--------------------------------------------------------------------------------
using UnityEngine;
using System.Collections.Generic;

namespace VoidWarranty.Core
{
    [CreateAssetMenu(fileName = "New Language", menuName = "VoidWarranty/Localization Table")]
    public class LocalizationTable : ScriptableObject
    {
        [Header("Configuration")]
        public string LanguageName = "English";
        public string LanguageCode = "en_US";

        [Header("Import (Fichier CSV)")]
        [Tooltip("Glisse ton fichier .csv ici")]
        public TextAsset CsvFile;

        [Header("Données (Générées auto)")]
        [SerializeField] private List<TranslationEntry> _entries;

        // Dictionnaire pour la recherche rapide en jeu
        private Dictionary<string, string> _lookup;

        // --- BOUTON D'IMPORTATION ---
        [ContextMenu("Importer depuis CSV")]
        public void ImportFromCsv()
        {
            if (CsvFile == null)
            {
                Debug.LogError("Aucun fichier CSV assigné !");
                return;
            }

            _entries = new List<TranslationEntry>();

            // On découpe les lignes
            string[] lines = CsvFile.text.Split('\n');

            foreach (string line in lines)
            {
                if (string.IsNullOrWhiteSpace(line)) continue;
                if (line.StartsWith("KEY;")) continue; // On ignore l'en-tête

                // On découpe au point-virgule
                string[] parts = line.Split(';');

                if (parts.Length >= 2)
                {
                    string key = parts[0].Trim();
                    string value = parts[1].Trim();

                    // Gestion des sauts de ligne (Excel utilise parfois <br> ou \n)
                    value = value.Replace("<br>", "\n").Replace("\n", "\n");

                    _entries.Add(new TranslationEntry { Key = key, Value = value });
                }
            }

            Debug.Log($"Succès ! {_entries.Count} traductions importées depuis {CsvFile.name}.");
        }

        // --- INITIALISATION RUNTIME ---
        public void Initialize()
        {
            _lookup = new Dictionary<string, string>();
            foreach (var entry in _entries)
            {
                if (!_lookup.ContainsKey(entry.Key))
                {
                    _lookup.Add(entry.Key, entry.Value);
                }
            }
        }

        public string Get(string key)
        {
            if (_lookup == null) Initialize();

            if (_lookup.TryGetValue(key, out string value)) return value;

            return $"[{key}]"; // Retourne [CLÉ_MANQUANTE] pour debug
        }

        [System.Serializable]
        public struct TranslationEntry
        {
            public string Key;
            [TextArea] public string Value;
        }
    }
}

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FICHIER: ColorCube.cs
PATH: Assets/_Game/Scripts/Interaction/ColorCube.cs
--------------------------------------------------------------------------------
using UnityEngine;
using VoidWarranty.Core;

namespace VoidWarranty.Interaction
{
    public class ColorCube : MonoBehaviour/*, IInteractable*/
    {
        public void Interact(GameObject interactor)
        {
            Debug.Log("Interaction reçue ! Changement de couleur.");

            // Juste pour le test visuel local immédiat
            GetComponent<Renderer>().material.color = Random.ColorHSV();
        }

        /*public string GetInteractionPrompt()
        {
            return "Changer Couleur";
        }*/
    }
}

--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FICHIER: GrabbableObject.cs
PATH: Assets/_Game/Scripts/Interaction/GrabbableObject.cs
--------------------------------------------------------------------------------
using UnityEngine;
using FishNet.Object;
using FishNet.Object.Synchronizing;
using VoidWarranty.Core;

namespace VoidWarranty.Interaction
{
    [RequireComponent(typeof(Rigidbody))]
    [RequireComponent(typeof(NetworkObject))]
    public class GrabbableObject : NetworkBehaviour, IInteractable
    {
        [SerializeField] protected ItemData _data;

        protected Rigidbody _rb;
        protected int _defaultLayer;

        public readonly SyncVar<bool> IsHeld = new SyncVar<bool>();

        protected virtual void Awake()
        {
            _rb = GetComponent<Rigidbody>();
            _defaultLayer = gameObject.layer;
            _rb.interpolation = RigidbodyInterpolation.Interpolate;

            if (_data != null)
            {
                _rb.mass = _data.Mass;
                _rb.linearDamping = _data.LinearDamping;
                _rb.angularDamping = _data.AngularDamping;
            }

            IsHeld.OnChange += OnHeldChanged;
        }

        private void OnDestroy()
        {
            IsHeld.OnChange -= OnHeldChanged;
        }

        private void OnHeldChanged(bool oldValue, bool newValue, bool asServer)
        {
            if (newValue == true)
            {
                if (!base.IsOwner)
                {
                    _rb.isKinematic = true;
                    _rb.useGravity = false;
                }
                else
                {
                    _rb.isKinematic = false;
                    _rb.useGravity = false;
                    _rb.linearDamping = 10f;
                    _rb.angularDamping = 10f;
                }
                SetLayerRecursively(gameObject, LayerMask.NameToLayer("Ignore Raycast"));
            }
            else
            {
                _rb.isKinematic = false;
                _rb.useGravity = true;
                SetLayerRecursively(gameObject, _defaultLayer);

                if (_data != null)
                {
                    _rb.linearDamping = _data.LinearDamping;
                    _rb.angularDamping = _data.AngularDamping;
                }
                else
                {
                    _rb.linearDamping = 0f;
                    _rb.angularDamping = 0.05f;
                }
            }
        }

        public virtual void OnGrabbed(Transform playerTransform)
        {
            if (base.IsServerInitialized) 
            {
                IsHeld.Value = true;
            }
            else 
            {
                ServerSetHeld(true);
            }
        }

        public virtual void OnDropped()
        {
            if (base.IsServerInitialized) 
            {
                IsHeld.Value = false;
            }
            else 
            {
                ServerSetHeld(false);
            }
        }

        [ServerRpc(RequireOwnership = false)]
        private void ServerSetHeld(bool state)
        {
            IsHeld.Value = state;
        }

        public Rigidbody GetRigidbody() => _rb;
        public ItemData GetData() => _data;
        public virtual void Interact(GameObject interactor) { }

        private void SetLayerRecursively(GameObject obj, int newLayer)
        {
            if (obj == null) return;
            obj.layer = newLayer;
            foreach (Transform child in obj.transform)
            {
                if (child == null) continue;
                SetLayerRecursively(child.gameObject, newLayer);
            }
        }

        public virtual string GetInteractionPrompt()
        {
            if (_data == null) return "Unknown Object";
            string name = LocalizationManager.Get(_data.NameKey);
            string action = LocalizationManager.Get("ACTION_TAKE");
            return $"{name}\n<size=80%><color=yellow>[{action}]</color></size>";
        }
    }
}

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FICHIER: PatientObject.cs (PARTIE 1/2)
PATH: Assets/_Game/Scripts/Interaction/PatientObject.cs
--------------------------------------------------------------------------------
// PatientObject.cs - Le systeme a reparer (ex: refroidissement du data center)
// State Machine a 4 etats : INFECTED -> DISMANTLING -> EMPTY -> REPAIRED

using UnityEngine;
using UnityEngine.UI;
using FishNet.Object;
using VoidWarranty.Core;
using VoidWarranty.Player;
using System.Collections.Generic;

namespace VoidWarranty.Interaction
{
    public class PatientObject : NetworkBehaviour, IInteractable
    {
        public enum PatientState
        {
            Infected,
            Dismantling,
            Empty,
            Repaired
        }

        [Header("Repair Settings")]
        [SerializeField] private float _baseRepairTime = 5f;
        [SerializeField] private float _advancedSpeedMultiplier = 2f;
        [SerializeField] private float _maxInteractionDistance = 4f;
        [SerializeField] private float _installDuration = 1.5f;

        [Header("Spawn - Piece Corrompue")]
        [SerializeField] private GameObject _infectedNodePrefab;
        [SerializeField] private Transform  _nodeSpawnPoint;

        [Header("Accepted Spare Part Type")]
        [SerializeField] private ItemType _requiredSpareType = ItemType.Motor;

        [Header("Visual Feedback")]
        [SerializeField] private GameObject    _cables;
        [SerializeField] private ParticleSystem _smokeEffect;
        [SerializeField] private GameObject    _infectedVisual;
        [SerializeField] private GameObject    _repairedVisual;

        [Header("UI - Progress Bar (World Space)")]
        [SerializeField] private Canvas _progressBarCanvas;
        [SerializeField] private Image  _progressBarFill;

        [Header("Audio")]
        [SerializeField] private AudioSource _audioSource;
        [SerializeField] private AudioClip   _dismantleLoopClip;
        [SerializeField] private AudioClip   _dismantleCompleteClip;
        [SerializeField] private AudioClip   _installClip;

        private PatientState _currentState = PatientState.Infected;
        private float _currentProgress = 0f;
        private float _installProgress = 0f;
        private GameObject _installerPlayer;
        private Dictionary<GameObject, float> _activeRepairers = new Dictionary<GameObject, float>();

        private void Start()
        {
            if (_progressBarCanvas != null)
                _progressBarCanvas.enabled = false;

            if (_repairedVisual != null)
                _repairedVisual.SetActive(false);

            if (_infectedVisual != null)
                _infectedVisual.SetActive(true);
        }

        private void Update()
        {
            if (!base.IsServerInitialized) return;

            switch (_currentState)
            {
                case PatientState.Dismantling:
                    UpdateDismantling();
                    break;

                case PatientState.Empty:
                    UpdateInstalling();
                    break;
            }
        }

        public void Interact(GameObject interactor)
        {
            PlayerGrab grab = interactor.GetComponent<PlayerGrab>();
            GrabbableObject heldObject = (grab != null) ? grab.GetHeldObject() : null;
            CmdInteract(interactor, heldObject);
        }

        [ServerRpc(RequireOwnership = false)]
        private void CmdInteract(GameObject interactor, GrabbableObject heldObject)
        {
            switch (_currentState)
            {
                case PatientState.Infected:
                    TryStartDismantle(interactor, heldObject);
                    break;

                case PatientState.Empty:
                    TryStartInstall(interactor, heldObject);
                    break;

                case PatientState.Dismantling:
                    TryJoinDismantle(interactor, heldObject);
                    break;

                case PatientState.Repaired:
                    break;
            }
        }

        private void TryStartDismantle(GameObject interactor, GrabbableObject tool)
        {
            float power = GetToolPower(tool);

            if (power <= 0f)
            {
                ObserversShowFeedback(interactor, "FEEDBACK_NEED_TOOLBOX");
                return;
            }

            _activeRepairers[interactor] = power;
            _currentState = PatientState.Dismantling;
            _currentProgress = 0f;

            ObserversSetUIActive(true);
            ObserversPlayDismantleLoop(true);
        }

        private void TryJoinDismantle(GameObject interactor, GrabbableObject tool)
        {
            if (_activeRepairers.ContainsKey(interactor)) return;

            float power = GetToolPower(tool);
            if (power <= 0f)
            {
                ObserversShowFeedback(interactor, "FEEDBACK_NEED_TOOLBOX");
                return;
            }

            _activeRepairers[interactor] = power;
        }

        private void UpdateDismantling()
        {
            float totalPower = 0f;
            List<GameObject> toRemove = new List<GameObject>();

            foreach (var kvp in _activeRepairers)
            {
                GameObject player = kvp.Key;
                float power = kvp.Value;

                if (player == null ||
                    Vector3.Distance(transform.position, player.transform.position) > _maxInteractionDistance)
                {
                    toRemove.Add(player);
                }
                else
                {
                    totalPower += power;
                }
            }

            foreach (var p in toRemove)
                _activeRepairers.Remove(p);

            if (_activeRepairers.Count == 0)
            {
                CancelDismantle();
                return;
            }

            float progressStep = (Time.deltaTime / _baseRepairTime) * totalPower;
            _currentProgress += progressStep;

            ObserversUpdateProgress(_currentProgress);

            if (_currentProgress >= 1f)
            {
                CompleteDismantling();
            }
        }

        private void CancelDismantle()
        {
            _currentState = PatientState.Infected;
            _currentProgress = 0f;
            _activeRepairers.Clear();

            ObserversSetUIActive(false);
            ObserversPlayDismantleLoop(false);
        }

        private void CompleteDismantling()
        {
            _currentState = PatientState.Empty;
            _currentProgress = 0f;
            _activeRepairers.Clear();

            if (_infectedNodePrefab != null && _nodeSpawnPoint != null)
            {
                GameObject instance = Instantiate(
                    _infectedNodePrefab,
                    _nodeSpawnPoint.position,
                    Quaternion.identity
                );
                Spawn(instance);
            }

            ObserversOnDismantleComplete();
        }

        [ObserversRpc]
        private void ObserversOnDismantleComplete()
        {
            if (_infectedVisual != null)
                _infectedVisual.SetActive(false);

            if (_cables != null)
                _cables.SetActive(false);
            if (_smokeEffect != null)
                _smokeEffect.Stop();

            if (_progressBarCanvas != null)
                _progressBarCanvas.enabled = false;

            if (_audioSource != null && _dismantleCompleteClip != null)
                _audioSource.PlayOneShot(_dismantleCompleteClip);
        }

        private void TryStartInstall(GameObject interactor, GrabbableObject heldObject)
        {
            if (heldObject == null)
            {
                ObserversShowFeedback(interactor, "FEEDBACK_NEED_SPARE_PART");
                return;
            }

            ItemData data = heldObject.GetData();
            if (data == null || data.Type != _requiredSpareType || data.IsDefective)
            {
                ObserversShowFeedback(interactor, "FEEDBACK_WRONG_PART");
                return;
            }

            PlayerGrab grab = interactor.GetComponent<PlayerGrab>();
            if (grab != null)
                grab.ForceDrop();

            if (heldObject.NetworkObject != null)
                heldObject.NetworkObject.Despawn();

            _installerPlayer = interactor;
            _installProgress = 0f;

            ObserversSetUIActive(true);
        }

        private void UpdateInstalling()
        {
            if (_installerPlayer == null)
            {
                CancelInstall();
                return;
            }

            if (Vector3.Distance(transform.position, _installerPlayer.transform.position) > _maxInteractionDistance)
            {
                CancelInstall();
                return;
            }

            _installProgress += Time.deltaTime / _installDuration;
            ObserversUpdateProgress(_installProgress);

            if (_installProgress >= 1f)
            {
                CompleteInstall();
            }
        }

        private void CancelInstall()
        {
            _installerPlayer = null;
            _installProgress = 0f;

            ObserversSetUIActive(false);
        }

        private void CompleteInstall()
        {
            _currentState = PatientState.Repaired;
            _installerPlayer = null;

            ObserversOnInstallComplete();
        }

        [ObserversRpc]
        private void ObserversOnInstallComplete()
        {
            if (_repairedVisual != null)
                _repairedVisual.SetActive(true);

            if (_progressBarCanvas != null)
                _progressBarCanvas.enabled = false;

            if (_audioSource != null && _installClip != null)
                _audioSource.PlayOneShot(_installClip);

            Debug.Log("Patient repare - piece neuve installee !");
        }

        private float GetToolPower(GrabbableObject tool)
        {
            if (tool == null) return 0f;

            ItemData data = tool.GetData();
            if (data == null) return 0f;

            switch (data.Type)
            {
                case ItemType.Toolbox:         return 1f;
                case ItemType.ToolboxAdvanced:  return _advancedSpeedMultiplier;
                default:                        return 0f;
            }
        }

        [ObserversRpc]
        private void ObserversUpdateProgress(float progress)
        {
            if (_progressBarCanvas != null)
            {
                if (!_progressBarCanvas.enabled)
                    _progressBarCanvas.enabled = true;

                if (_progressBarFill != null)
                    _progressBarFill.fillAmount = progress;
            }
        }

        [ObserversRpc]
        private void ObserversSetUIActive(bool isActive)
        {
            if (_progressBarCanvas != null)
                _progressBarCanvas.enabled = isActive;

            if (!isActive && _progressBarFill != null)
                _progressBarFill.fillAmount = 0f;
        }

        [ObserversRpc]
        private void ObserversPlayDismantleLoop(bool play)
        {
            if (_audioSource == null || _dismantleLoopClip == null) return;

            if (play)
            {
                _audioSource.clip = _dismantleLoopClip;
                _audioSource.loop = true;
                _audioSource.Play();
            }
            else
            {
                _audioSource.Stop();
                _audioSource.loop = false;
            }
        }

        [ObserversRpc]
        private void ObserversShowFeedback(GameObject target, string locKey)
        {
            Debug.Log($"[Patient] Feedback pour {target.name}: {LocalizationManager.Get(locKey)}");
        }

        public string GetInteractionPrompt()
        {
            switch (_currentState)
            {
                case PatientState.Infected:
                    return LocalizationManager.Get("ACTION_DISMANTLE");

                case PatientState.Dismantling:
                    return LocalizationManager.Get("ACTION_REPAIR_JOIN");

                case PatientState.Empty:
                    return LocalizationManager.Get("ACTION_INSTALL_PART");

                case PatientState.Repaired:
                    return LocalizationManager.Get("STATUS_REPAIRED");

                default:
                    return "";
            }
        }
    }
}

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FICHIER: RepairSocket.cs
PATH: Assets/_Game/Scripts/Interaction/RepairSocket.cs
--------------------------------------------------------------------------------
using UnityEngine;
using FishNet.Object;
using VoidWarranty.Core;
using VoidWarranty.Player;

namespace VoidWarranty.Interaction
{
    public class RepairSocket : NetworkBehaviour, IInteractable
    {
        [Header("Configuration")]
        [SerializeField] private ItemType _requiredType;
        [SerializeField] private Transform _socketPoint;

        [Header("Initial State")]
        [SerializeField] private GrabbableObject _startingItem;

        private GrabbableObject _installedItem;

        public override void OnStartServer()
        {
            base.OnStartServer();
            if (_startingItem != null)
            {
                GameObject instance = Instantiate(_startingItem.gameObject, _socketPoint.position, _socketPoint.rotation);
                base.Spawn(instance);
                GrabbableObject newItem = instance.GetComponent<GrabbableObject>();
                AttachItem(newItem);
            }
        }

        public void Interact(GameObject interactor)
        {
            PlayerGrab playerHand = interactor.GetComponent<PlayerGrab>();
            if (playerHand == null) return;
            CmdHandleInteraction(playerHand);
        }

        [ServerRpc(RequireOwnership = false)]
        private void CmdHandleInteraction(PlayerGrab playerHand)
        {
            GrabbableObject handItem = playerHand.GetHeldObject();
            ItemData handData = handItem != null ? handItem.GetData() : null;

            if (_installedItem == null && handItem != null)
            {
                if (handData != null && handData.Type == _requiredType)
                {
                    playerHand.ForceDrop();
                    AttachItem(handItem);
                    Debug.Log("[SOCKET] Installation reussie.");
                }
                else
                {
                    Debug.LogWarning($"[SOCKET] Mauvais type. Attendu: {_requiredType}, Recu: {handData?.Type}");
                }
            }
            else if (_installedItem != null && handItem == null)
            {
                Debug.Log("[SOCKET] Ejection de la piece.");
                DetachItem();
            }
            else if (_installedItem != null && handItem != null)
            {
                Debug.Log("[SOCKET] ACTION INTERDITE : Retirez d'abord la piece actuelle !");
            }
        }

        private void AttachItem(GrabbableObject item)
        {
            _installedItem = item;

            Rigidbody rb = item.GetRigidbody();
            if (rb != null) rb.isKinematic = true;

            item.transform.position = _socketPoint.position;
            item.transform.rotation = _socketPoint.rotation;
            item.transform.SetParent(_socketPoint);

            SetLayerRecursively(item.gameObject, LayerMask.NameToLayer("Ignore Raycast"));
        }

        private void DetachItem()
        {
            if (_installedItem == null) return;

            GrabbableObject item = _installedItem;

            Rigidbody rb = item.GetRigidbody();
            if (rb != null)
            {
                rb.isKinematic = false;
                rb.AddForce(transform.forward * 2f + Vector3.up, ForceMode.Impulse);
            }

            item.transform.SetParent(null);

            SetLayerRecursively(item.gameObject, LayerMask.NameToLayer("Interactable"));

            _installedItem = null;
        }

        private void SetLayerRecursively(GameObject obj, int newLayer)
        {
            if (obj == null) return;
            obj.layer = newLayer;
            foreach (Transform child in obj.transform)
            {
                if (child == null) continue;
                SetLayerRecursively(child.gameObject, newLayer);
            }
        }

        public string GetInteractionPrompt()
        {
            string key = (_installedItem == null) ? "ACTION_INSERT" : "ACTION_REMOVE";
            return LocalizationManager.Get(key);
        }
    }
}

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FICHIER: Scanner.cs (PARTIE 1/2)
PATH: Assets/_Game/Scripts/Interaction/Scanner.cs
--------------------------------------------------------------------------------
using UnityEngine;
using UnityEngine.UI;
using VoidWarranty.Core;

namespace VoidWarranty.Interaction
{
    public class Scanner : GrabbableObject
    {
        [Header("Scanner UI References")]
        [SerializeField] private Canvas _uiCanvas;
        [SerializeField] private RectTransform _radarScreen;
        [SerializeField] private RectTransform _blip;

        [Header("Audio")]
        [SerializeField] private AudioSource _audioSource;
        [SerializeField] private AudioClip _beepClip;

        [Header("Radar Settings")]
        [SerializeField] private float _maxRadarRange = 50f;
        [SerializeField] private float _radarRadius = 100f;
        [SerializeField] private Color _blipColor = Color.green;
        [SerializeField] private float _blipFadeSpeed = 3f;

        [Header("Audio Frequency")]
        [SerializeField] private float _maxBeepInterval = 2f;
        [SerializeField] private float _minBeepInterval = 0.1f;
        [SerializeField] private float _continuousDistance = 5f;

        [Header("Optimization")]
        [SerializeField] private float _updateRate = 0.05f;
        [SerializeField] private float _scanRate = 0.5f;

        private Transform _targetTransform;
        private Transform _playerTransform;
        private Image _blipImage;
        private bool _isActive = false;

        private float _updateTimer = 0f;
        private float _scanTimer = 0f;
        private float _beepTimer = 0f;
        private float _currentBlipAlpha = 0f;

        protected override void Awake()
        {
            base.Awake();

            ScanForTarget();

            if (_blip != null && _blip.TryGetComponent(out _blipImage))
            {
                _blipImage.color = _blipColor;
                Color c = _blipImage.color;
                c.a = 0f;
                _blipImage.color = c;
            }

            if (_uiCanvas != null) _uiCanvas.enabled = false;
        }

        private void Update()
        {
            if (!_isActive || _playerTransform == null) return;

            _scanTimer += Time.deltaTime;
            if (_scanTimer >= _scanRate)
            {
                _scanTimer = 0f;
                ScanForTarget();
            }

            if (_targetTransform == null) return;

            _updateTimer += Time.deltaTime;
            if (_updateTimer >= _updateRate)
            {
                _updateTimer = 0f;
                UpdateRadarPosition();
            }

            UpdateBeepAndFlash();
            UpdateBlipFade();
        }

        private void ScanForTarget()
        {
            _targetTransform = null;
            float closestDist = float.MaxValue;
            Vector3 myPos = transform.position;

            GrabbableObject[] allProps = FindObjectsByType<GrabbableObject>(FindObjectsSortMode.None);

            foreach (var prop in allProps)
            {
                ItemData data = prop.GetData();
                if (data != null && data.IsDefective)
                {
                    float d = Vector3.Distance(myPos, prop.transform.position);
                    if (d < closestDist)
                    {
                        closestDist = d;
                        _targetTransform = prop.transform;
                    }
                }
            }

            if (_targetTransform != null) return;

            PatientObject[] patients = FindObjectsByType<PatientObject>(FindObjectsSortMode.None);
            foreach (var patient in patients)
            {
                float d = Vector3.Distance(myPos, patient.transform.position);
                if (d < closestDist)
                {
                    closestDist = d;
                    _targetTransform = patient.transform;
                }
            }
        }

        private void UpdateRadarPosition()
        {
            if (_blip == null || _targetTransform == null) return;

            Vector3 directionToTarget = _targetTransform.position - _playerTransform.position;
            Vector3 localDirection = _playerTransform.InverseTransformDirection(directionToTarget);

            float distance = directionToTarget.magnitude;
            float normalizedDist = Mathf.Clamp01(distance / _maxRadarRange);
            float angle = Mathf.Atan2(localDirection.x, localDirection.z) * Mathf.Rad2Deg;

            Vector2 blipPos = new Vector2(
                Mathf.Sin(angle * Mathf.Deg2Rad) * normalizedDist * _radarRadius,
                Mathf.Cos(angle * Mathf.Deg2Rad) * normalizedDist * _radarRadius
            );

            _blip.anchoredPosition = blipPos;
        }

        private void UpdateBeepAndFlash()
        {
            if (_audioSource == null || _beepClip == null || _targetTransform == null) return;

            float distance = Vector3.Distance(_playerTransform.position, _targetTransform.position);

            float interval;
            if (distance < _continuousDistance) interval = 0.05f;
            else
            {
                float t = distance / _maxRadarRange;
                interval = Mathf.Lerp(_minBeepInterval, _maxBeepInterval, Mathf.Clamp01(t));
            }

            _beepTimer += Time.deltaTime;

            if (_beepTimer >= interval)
            {
                _beepTimer = 0f;
                _audioSource.PlayOneShot(_beepClip);
                _currentBlipAlpha = 1f;
            }
        }

        private void UpdateBlipFade()
        {
            if (_blipImage == null) return;
            _currentBlipAlpha = Mathf.MoveTowards(_currentBlipAlpha, 0f, Time.deltaTime * _blipFadeSpeed);
            Color c = _blipColor;
            c.a = _currentBlipAlpha;
            _blipImage.color = c;
        }

        public override void OnGrabbed(Transform playerTransform)
        {
            base.OnGrabbed(playerTransform);
            _playerTransform = playerTransform;
            _isActive = true;
            if (_uiCanvas != null) _uiCanvas.enabled = true;
            _beepTimer = 0f;
            _currentBlipAlpha = 0f;

            ScanForTarget();
        }

        public override void OnDropped()
        {
            base.OnDropped();
            _isActive = false;
            _playerTransform = null;
            if (_uiCanvas != null) _uiCanvas.enabled = false;
            if (_audioSource != null) _audioSource.Stop();
        }

        public override string GetInteractionPrompt()
        {
            string name = (_data != null) ? LocalizationManager.Get(_data.NameKey) : "Scanner";
            string action = LocalizationManager.Get("ACTION_TAKE");
            return $"{name}\n<size=80%><color=yellow>[{action}]</color></size>";
        }
    }
}

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FICHIER: SupplyCrate.cs
PATH: Assets/_Game/Scripts/Interaction/SupplyCrate.cs
--------------------------------------------------------------------------------
using UnityEngine;
using FishNet.Object;
using VoidWarranty.Core;

namespace VoidWarranty.Interaction
{
    public class SupplyCrate : GrabbableObject
    {
        [Header("Supply Crate")]
        [SerializeField] private GameObject _lid;
        [SerializeField] private GameObject _sparePart;
        [SerializeField] private Transform  _spawnPoint;
        [SerializeField] private GameObject _sparePartPrefab;

        [Header("Audio")]
        [SerializeField] private AudioSource _audioSource;
        [SerializeField] private AudioClip   _openSound;

        private bool _isOpen = false;

        protected override void Awake()
        {
            base.Awake();

            if (_sparePart != null)
                _sparePart.SetActive(false);
        }

        public override void Interact(GameObject interactor)
        {
            if (_isOpen) return;
            if (IsHeld.Value) return;

            CmdRequestOpen();
        }

        [ServerRpc(RequireOwnership = false)]
        private void CmdRequestOpen()
        {
            if (_isOpen) return;

            _isOpen = true;

            SpawnSparePart();

            ObserversOnCrateOpened();
        }

        [ObserversRpc]
        private void ObserversOnCrateOpened()
        {
            _isOpen = true;

            if (_lid != null)
                _lid.SetActive(false);

            if (_audioSource != null && _openSound != null)
                _audioSource.PlayOneShot(_openSound);
        }

        private void SpawnSparePart()
        {
            if (_sparePart != null)
            {
                _sparePart.transform.SetParent(null);
                _sparePart.SetActive(true);

                if (_sparePart.TryGetComponent(out NetworkObject netObj))
                {
                    Spawn(netObj);
                }

                return;
            }

            if (_sparePartPrefab != null && _spawnPoint != null)
            {
                GameObject instance = Instantiate(
                    _sparePartPrefab,
                    _spawnPoint.position,
                    _spawnPoint.rotation
                );

                Spawn(instance);
            }
        }

        public override string GetInteractionPrompt()
        {
            if (_isOpen)
            {
                string name = (_data != null) ? LocalizationManager.Get(_data.NameKey) : "Caisse";
                string action = LocalizationManager.Get("ACTION_TAKE");
                return $"{name}\n<size=80%><color=yellow>[{action}]</color></size>";
            }

            if (IsHeld.Value)
            {
                return "";
            }

            string openAction = LocalizationManager.Get("ACTION_OPEN_CRATE");
            return $"{LocalizationManager.Get("ITEM_SUPPLY_CRATE")}\n<size=80%><color=yellow>[{openAction}]</color></size>";
        }
    }
}

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FICHIER: TruckZone.cs
PATH: Assets/_Game/Scripts/Interaction/TruckZone.cs
--------------------------------------------------------------------------------
using UnityEngine;
using FishNet.Object;
using FishNet.Component.Transforming;
using VoidWarranty.Core;

namespace VoidWarranty.Interaction
{
    public class TruckZone : NetworkBehaviour
    {
        private void OnTriggerEnter(Collider other)
        {
            if (!base.IsServer) return;

            if (other.TryGetComponent(out GrabbableObject item))
            {
                ItemData data = item.GetData();
                if (data != null)
                {
                    if (data.IsDefective)
                    {
                        Debug.Log($"CONTRAT VALIDE : Piece defectueuse {data.NameKey} recuperee !");

                        if (item.TryGetComponent(out NetworkTransform nt))
                        {
                            nt.enabled = false;
                        }

                        item.NetworkObject.Despawn();
                    }
                    else
                    {
                        Debug.Log($"REFUSE : Vous avez ramene une piece neuve ({data.NameKey}).");
                    }
                }
            }
        }
    }
}

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FICHIER: PlayerCameraSetup.cs
PATH: Assets/_Game/Scripts/Player/PlayerCameraSetup.cs
--------------------------------------------------------------------------------
using UnityEngine;
using FishNet.Object;

namespace VoidWarranty.Player
{
    public class PlayerCameraSetup : NetworkBehaviour
    {
        [Header("References")]
        [SerializeField] private Transform _cameraRoot;

        public override void OnStartClient()
        {
            base.OnStartClient();

            if (!base.IsOwner)
            {
                return;
            }

            Camera sceneCamera = Camera.main;

            if (sceneCamera != null)
            {
                sceneCamera.transform.SetParent(null);

                sceneCamera.transform.SetParent(_cameraRoot);

                sceneCamera.transform.localPosition = Vector3.zero;
                sceneCamera.transform.localRotation = Quaternion.identity;
            }
            else
            {
                Debug.LogError("Aucune MainCamera trouvee dans la scene !");
            }
        }
    }
}

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FICHIER: PlayerInputReader.cs
PATH: Assets/_Game/Scripts/Player/PlayerInputReader.cs
--------------------------------------------------------------------------------
using UnityEngine;
using UnityEngine.InputSystem;

namespace VoidWarranty.Player
{
    public class PlayerInputReader : MonoBehaviour, GameControls.IPlayerActions
    {
        public Vector2 MoveInput { get; private set; }
        public Vector2 LookInput { get; private set; }
        public bool IsSprinting { get; private set; }
        public bool IsCrouching { get; private set; }

        public event System.Action OnInteractEvent;
        public event System.Action OnGrabToggleEvent;
        public event System.Action OnJumpEvent;

        private GameControls _controls;

        private void OnEnable()
        {
            if (_controls == null)
            {
                _controls = new GameControls();
                _controls.Player.SetCallbacks(this);
            }
            _controls.Player.Enable();
        }

        private void OnDisable()
        {
            _controls.Player.Disable();
        }

        public void OnMove(InputAction.CallbackContext context)
        {
            MoveInput = context.ReadValue<Vector2>();
        }

        public void OnLook(InputAction.CallbackContext context)
        {
            LookInput = context.ReadValue<Vector2>();
        }

        public void OnSprint(InputAction.CallbackContext context)
        {
            if (context.performed) IsSprinting = true;
            else if (context.canceled) IsSprinting = false;
        }

        public void OnInteract(InputAction.CallbackContext context)
        {
            if (context.started) OnInteractEvent?.Invoke();
        }

        public void OnGrab(InputAction.CallbackContext context)
        {
            if (context.started) OnGrabToggleEvent?.Invoke();
        }

        public void OnJump(InputAction.CallbackContext context)
        {
            if (context.started) OnJumpEvent?.Invoke();
        }

        public void OnCrouch(InputAction.CallbackContext context)
        {
            if (context.performed) IsCrouching = true;
            else if (context.canceled) IsCrouching = false;
        }

        public void OnAttack(InputAction.CallbackContext context) { }
        public void OnPrevious(InputAction.CallbackContext context) { }
        public void OnNext(InputAction.CallbackContext context) { }
    }
}

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FICHIER: PlayerInteraction.cs
PATH: Assets/_Game/Scripts/Player/PlayerInteraction.cs
--------------------------------------------------------------------------------
using UnityEngine;
using FishNet.Object;
using VoidWarranty.Core;
using VoidWarranty.UI;

namespace VoidWarranty.Player
{
    public class PlayerInteraction : NetworkBehaviour
    {
        [Header("Settings")]
        [SerializeField] private float _interactDistance = 3f;
        [SerializeField] private LayerMask _interactLayer;

        [Header("References")]
        [SerializeField] private Transform _cameraRoot;
        [SerializeField] private PlayerInputReader _inputReader;

        private InteractionHUD _hud;

        public override void OnStartClient()
        {
            base.OnStartClient();
            if (!base.IsOwner) return;

            _inputReader.OnInteractEvent += HandleInteractInput;
            _hud = FindFirstObjectByType<InteractionHUD>();
        }

        public override void OnStopClient()
        {
            base.OnStopClient();
            if (!base.IsOwner) return;

            _inputReader.OnInteractEvent -= HandleInteractInput;
        }

        private void Update()
        {
            if (!base.IsOwner) return;
            ScanForInteractable();
        }

        private void ScanForInteractable()
        {
            if (_hud == null) return;

            Ray ray = new Ray(_cameraRoot.position, _cameraRoot.forward);

            if (Physics.Raycast(ray, out RaycastHit hit, _interactDistance, _interactLayer))
            {
                IInteractable interactable = hit.collider.GetComponentInParent<IInteractable>();
                if (interactable != null)
                {
                    string prompt = interactable.GetInteractionPrompt();
                    _hud.UpdatePrompt(prompt);
                    return;
                }
            }

            _hud.UpdatePrompt("");
        }

        private void HandleInteractInput()
        {
            Ray ray = new Ray(_cameraRoot.position, _cameraRoot.forward);

            if (Physics.Raycast(ray, out RaycastHit hit, _interactDistance, _interactLayer))
            {
                IInteractable interactable = hit.collider.GetComponentInParent<IInteractable>();
                if (interactable != null)
                {
                    interactable.Interact(this.gameObject);
                }
            }
        }
    }
}

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FICHIER: InteractionHUD.cs
PATH: Assets/_Game/Scripts/UI/InteractionHUD.cs
--------------------------------------------------------------------------------
using UnityEngine;
using TMPro;

namespace VoidWarranty.UI
{
    public class InteractionHUD : MonoBehaviour
    {
        [Header("References")]
        [SerializeField] private TextMeshProUGUI _promptText;
        [SerializeField] private GameObject _crosshair;

        private void Awake()
        {
            if (_promptText != null) _promptText.text = "";
        }

        public void UpdatePrompt(string message)
        {
            if (_promptText == null) return;

            _promptText.text = message;

            if (_crosshair != null)
            {
                bool isInteractable = !string.IsNullOrEmpty(message);
                _crosshair.transform.localScale = isInteractable ? Vector3.one * 1.5f : Vector3.one;
            }
        }
    }
}

--------------------------------------------------------------------------------

================================================================================
FIN DU DOCUMENT - VOID WARRANTY SCRIPTS v0.6
================================================================================
Total: 18 scripts documentes
Date de generation: 2026-02-08

Architecture:
- Settings: 1 script (GameControls auto-genere)
- Core: 4 scripts (interfaces, data, localisation)
- Interaction: 7 scripts (objets, patients, zones)
- Player: 5 scripts (camera, grab, input, interaction, movement)
- UI: 1 script (HUD)

================================================================================
--------------------------------------------------------------------------------
FICHIER: PlayerGrab.cs
PATH: Assets/_Game/Scripts/Player/PlayerGrab.cs
--------------------------------------------------------------------------------
using UnityEngine;
using FishNet.Object;
using FishNet.Connection;
using VoidWarranty.Interaction;
using VoidWarranty.Core;

namespace VoidWarranty.Player
{
    public class PlayerGrab : NetworkBehaviour
    {
        [Header("Settings")]
        [SerializeField] private float _grabDistance = 3f;
        [SerializeField] private float _throwForce = 5f;
        [SerializeField] private LayerMask _grabLayer;

        [Header("Physics Settings")]
        [SerializeField] private float _followSpeed = 20f;
        [SerializeField] private float _rotateSpeed = 20f;
        [SerializeField] private float _breakDistance = 1.5f;
        [SerializeField] private float _maxGrabVelocity = 15f;

        [Header("References")]
        [SerializeField] private Transform _cameraRoot;
        [SerializeField] private Transform _holdPoint;
        [SerializeField] private PlayerInputReader _inputReader;
        [SerializeField] private CharacterController _characterController;

        private GrabbableObject _currentObject;
        private Rigidbody _heldRb;

        public float CurrentHeldMass { get; private set; } = 0f;

        public override void OnStartClient()
        {
            base.OnStartClient();

            if (!base.IsOwner)
                enabled = false;
            else
                _inputReader.OnGrabToggleEvent += HandleGrabToggle;
        }

        public override void OnStopClient()
        {
            base.OnStopClient();

            if (base.IsOwner)
                _inputReader.OnGrabToggleEvent -= HandleGrabToggle;
        }

        private void HandleGrabToggle()
        {
            if (_currentObject == null)
                TryGrab();
            else
                Drop();
        }

        private void FixedUpdate()
        {
            if (!base.IsOwner || _currentObject == null || _heldRb == null) return;
            MoveObjectToHand();
        }

        private void MoveObjectToHand()
        {
            Vector3 targetPos = _holdPoint.position;
            Quaternion targetRot = _holdPoint.rotation;

            ItemData data = _currentObject.GetData();
            if (data != null)
            {
                targetPos += (_holdPoint.right * data.HeldPositionOffset.x) +
                             (_holdPoint.up * data.HeldPositionOffset.y) +
                             (_holdPoint.forward * data.HeldPositionOffset.z);

                targetRot *= Quaternion.Euler(data.HeldRotationOffset);
            }

            Vector3 direction = targetPos - _heldRb.position;
            float distance = direction.magnitude;

            if (distance > _breakDistance)
            {
                Drop();
                return;
            }

            Vector3 targetVelocity = direction * _followSpeed;
            _heldRb.linearVelocity = Vector3.ClampMagnitude(targetVelocity, _maxGrabVelocity);

            Quaternion rotationDiff = targetRot * Quaternion.Inverse(_heldRb.rotation);
            rotationDiff.ToAngleAxis(out float angleInDegrees, out Vector3 rotationAxis);

            if (float.IsInfinity(rotationAxis.x)) return;
            if (angleInDegrees > 180f) angleInDegrees -= 360f;

            Vector3 angularDisplacement = rotationAxis * (angleInDegrees * Mathf.Deg2Rad);
            _heldRb.angularVelocity = angularDisplacement * _rotateSpeed;
        }

        private void TryGrab()
        {
            Ray ray = new Ray(_cameraRoot.position, _cameraRoot.forward);

            if (Physics.Raycast(ray, out RaycastHit hit, _grabDistance, _grabLayer))
            {
                GrabbableObject grabbable = hit.collider.GetComponentInParent<GrabbableObject>();
                if (grabbable != null)
                {
                    CmdRequestGrab(grabbable);
                }
            }
        }

        [ServerRpc]
        private void CmdRequestGrab(GrabbableObject grabbable)
        {
            if (grabbable != null && grabbable.NetworkObject != null)
            {
                grabbable.NetworkObject.GiveOwnership(base.Owner);
                TargetGrabSuccess(base.Owner, grabbable);
            }
        }

        [TargetRpc]
        private void TargetGrabSuccess(NetworkConnection conn, GrabbableObject grabbable)
        {
            _currentObject = grabbable;
            _heldRb = _currentObject.GetRigidbody();

            ItemData data = _currentObject.GetData();
            CurrentHeldMass = (data != null) ? data.Mass : 5f;

            _currentObject.transform.SetParent(null);
            _currentObject.OnGrabbed(transform);

            _heldRb.linearVelocity = Vector3.zero;
            _heldRb.angularVelocity = Vector3.zero;
            _heldRb.position = _holdPoint.position;
            _heldRb.rotation = _holdPoint.rotation;

            Physics.SyncTransforms();
            ToggleCollisions(true);
        }

        private void Drop()
        {
            if (_currentObject == null) return;

            ToggleCollisions(false);

            float dropReach = 1.5f;
            Vector3 dropOrigin = _cameraRoot.position;
            Vector3 dropDirection = _cameraRoot.forward;
            Vector3 finalDropPos;

            int layerMask = ~LayerMask.GetMask("Player", "Ignore Raycast");

            if (Physics.Raycast(dropOrigin, dropDirection, out RaycastHit hit, dropReach, layerMask))
            {
                finalDropPos = hit.point - (dropDirection * 0.3f);
            }
            else
            {
                finalDropPos = dropOrigin + (dropDirection * dropReach);
            }

            _heldRb.position = finalDropPos;
            _currentObject.OnDropped();

            if (_heldRb != null)
                _heldRb.AddForce(_cameraRoot.forward * _throwForce, ForceMode.Impulse);

            _currentObject = null;
            _heldRb = null;
            CurrentHeldMass = 0f;
        }

        public GrabbableObject GetHeldObject() => _currentObject;

        public void ForceDrop()
        {
            if (_currentObject != null) Drop();
        }

        private void ToggleCollisions(bool ignore)
        {
            if (_currentObject == null) return;

            Collider[] colliders = _currentObject.GetComponentsInChildren<Collider>();
            foreach (var col in colliders)
            {
                Physics.IgnoreCollision(_characterController, col, ignore);
            }
        }
    }
}

--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
FICHIER: PlayerMovement.cs
PATH: Assets/_Game/Scripts/Player/PlayerMovement.cs
--------------------------------------------------------------------------------
using UnityEngine;
using FishNet.Object;

namespace VoidWarranty.Player
{
    [RequireComponent(typeof(CharacterController))]
    [RequireComponent(typeof(PlayerInputReader))]
    [RequireComponent(typeof(PlayerGrab))]
    public class PlayerMovement : NetworkBehaviour
    {
        [Header("Settings - Vitesse")]
        [SerializeField] private float _walkSpeed = 4f;
        [SerializeField] private float _runSpeed = 7f;
        [SerializeField] private float _crouchSpeed = 2f;

        [Header("Settings - Saut & Gravite")]
        [SerializeField] private float _jumpHeight = 1.2f;
        [SerializeField] private float _gravity = -9.81f;

        [Header("Settings - Accroupissement")]
        [Tooltip("Hauteur debout (ex: 2m pour un humain)")]
        [SerializeField] private float _standHeight = 2f;
        [Tooltip("Hauteur accroupi (ex: 1m)")]
        [SerializeField] private float _crouchHeight = 1f;
        [SerializeField] private float _crouchTransitionSpeed = 10f;
        [SerializeField] private Transform _cameraHolder;
        [Tooltip("De combien descend la camera quand on s'accroupit (en metres)")]
        [SerializeField] private float _crouchCameraOffset = 0.5f;
        [SerializeField] private LayerMask _ceilingLayer;

        [Header("Settings - Poids")]
        [SerializeField] private float _weightPenaltyFactor = 0.15f;
        [SerializeField] private float _minSpeed = 1.5f;

        [Header("Settings - Souris")]
        [SerializeField] private float _lookSensitivityX = 0.5f;
        [SerializeField] private float _lookSensitivityY = 0.5f;

        [Header("References")]
        [SerializeField] private Transform _cameraTarget;

        private CharacterController _characterController;
        private PlayerInputReader _inputReader;
        private PlayerGrab _playerGrab;

        private float _verticalRotation;
        private Vector3 _velocity;
        private bool _isCrouchingPhysically = false;

        private float _standingCameraHeight;

        private void Awake()
        {
            _characterController = GetComponent<CharacterController>();
            _inputReader = GetComponent<PlayerInputReader>();
            _playerGrab = GetComponent<PlayerGrab>();

            _characterController.height = _standHeight;
            _characterController.center = Vector3.zero;

            if (_cameraHolder != null)
            {
                _standingCameraHeight = _cameraHolder.localPosition.y;
                Debug.Log($"[PlayerMovement] Camera debout sauvegardee a Y={_standingCameraHeight}");
            }
        }

        public override void OnStartClient()
        {
            base.OnStartClient();

            if (!base.IsOwner)
            {
                _inputReader.enabled = false;
                return;
            }

            _inputReader.OnJumpEvent += HandleJump;

            Cursor.lockState = CursorLockMode.Locked;
            Cursor.visible = false;
        }

        public override void OnStopClient()
        {
            base.OnStopClient();
            if (base.IsOwner) _inputReader.OnJumpEvent -= HandleJump;
        }

        private void Update()
        {
            if (!base.IsOwner) return;

            HandleRotation();
            HandleCrouch();
            HandleMovement();
        }

        private void HandleRotation()
        {
            Vector2 look = _inputReader.LookInput;
            float mouseX = look.x * _lookSensitivityX;
            float mouseY = look.y * _lookSensitivityY;

            transform.Rotate(Vector3.up * mouseX);

            _verticalRotation -= mouseY;
            _verticalRotation = Mathf.Clamp(_verticalRotation, -85f, 85f);

            if (_cameraTarget != null)
                _cameraTarget.localRotation = Quaternion.Euler(_verticalRotation, 0f, 0f);
        }

        private void HandleJump()
        {
            if (_characterController.isGrounded)
            {
                _velocity.y = Mathf.Sqrt(_jumpHeight * -2f * _gravity);
            }
        }

        private void HandleCrouch()
        {
            bool wantsToCrouch = _inputReader.IsCrouching;

            if (!wantsToCrouch && _isCrouchingPhysically)
            {
                Vector3 origin = transform.position + Vector3.up * _crouchHeight;
                float distanceToCheck = _standHeight - _crouchHeight + 0.1f;

                if (Physics.Raycast(origin, Vector3.up, distanceToCheck, _ceilingLayer))
                {
                    wantsToCrouch = true;
                }
            }

            if (_isCrouchingPhysically != wantsToCrouch)
            {
                _isCrouchingPhysically = wantsToCrouch;
                float targetHeight = _isCrouchingPhysically ? _crouchHeight : _standHeight;

                _characterController.enabled = false;
                _characterController.height = targetHeight;
                _characterController.center = Vector3.zero;
                _characterController.enabled = true;

                Physics.SyncTransforms();
            }

            if (_cameraHolder != null)
            {
                float targetCamHeight;

                if (_isCrouchingPhysically)
                {
                    targetCamHeight = _standingCameraHeight - _crouchCameraOffset;
                }
                else
                {
                    targetCamHeight = _standingCameraHeight;
                }

                Vector3 camPos = _cameraHolder.localPosition;
                camPos.y = Mathf.Lerp(camPos.y, targetCamHeight, Time.deltaTime * _crouchTransitionSpeed);
                _cameraHolder.localPosition = camPos;
            }
        }

        private void HandleMovement()
        {
            if (_characterController.isGrounded && _velocity.y < 0)
            {
                _velocity.y = -2f;
            }

            Vector2 moveInput = _inputReader.MoveInput;
            Vector3 moveDir = transform.right * moveInput.x + transform.forward * moveInput.y;
            if (moveDir.magnitude > 1f) moveDir.Normalize();

            float baseSpeed;
            if (_isCrouchingPhysically)
                baseSpeed = _crouchSpeed;
            else
                baseSpeed = _inputReader.IsSprinting ? _runSpeed : _walkSpeed;

            float currentMass = _playerGrab.CurrentHeldMass;
            float dynamicSpeed = baseSpeed - (currentMass * _weightPenaltyFactor);
            dynamicSpeed = Mathf.Max(dynamicSpeed, _minSpeed);

            _velocity.y += _gravity * Time.deltaTime;
            _characterController.Move((moveDir * dynamicSpeed + _velocity) * Time.deltaTime);
        }

        [ContextMenu("Debug Character Controller")]
        private void DebugCharacterController()
        {
            Debug.Log($"=== CHARACTER CONTROLLER DEBUG ===");
            Debug.Log($"Height: {_characterController.height}");
            Debug.Log($"Center: {_characterController.center}");
            Debug.Log($"Player Position: {transform.position}");
            Debug.Log($"Is Crouching: {_isCrouchingPhysically}");
            Debug.Log($"Standing Camera Height: {_standingCameraHeight}");
            Debug.Log($"Current Camera Height: {(_cameraHolder != null ? _cameraHolder.localPosition.y : 0)}");
            Debug.Log($"==================================");
        }
    }
}

--------------------------------------------------------------------------------
